#!/bin/bash
# 
# If you create a variable called BASH_ENV in your .bash_profile, like so:
#    export BASH_ENV="~/.bash_env"
# then create a file called ".bash_env" in your home directory, that file 
# will be re-read every time you start a `non-login non-interactive shell' 
#    - i.e., a shell script. 
#
# FUTURE: create man pages for each function
#
# [please leave this message here so i will be reminded when i haven't
#  used shell scripts in a few months, and attempt to do the same again  ]
# 
# i have just spent an incredibly painful **THREE** hours attempting
# to get a simple search and replace working...
# 
# RULE #1 :  If you are having problems and you script uses backticks try using 'eval' instead
#            or both, ie. `eval ls -l`
# RULE #2 :  NEVER PUT SPACES BETWEEN THE REFERENCE, THE EQUALS SIGN and THE VALUE
#            ie. A="${something}" or B=`ls -l`
#            and NOT A = "blah"
# RULE #3 :  String handling is not always as expected. For a little test script I'm writing 
#            I needed to split a line on a ';' but preservere the "s and 's, something that 
#            echo doesn't like to do. Digging deeper into the bash docs I see that there 
#            are some handy string handling functions.
#
#            line='this "is" a command;this "is" a pattern'
#            COMMAND=${line%;*}
#            PATTERN=${line#*;}
#            echo $COMMAND
#            echo $PATTERN
#
#            see http://www.museum.state.il.us/ismdepts/library/linuxguides/abs-guide/string-manipulation.html
# RULE #4 :  Variable scope. All variables within functions are *GLOBAL* by default. Use
#            the bash 'local' builtin to specify that the variable is just local to a
#            function. 
#            Be extra careful with counters for 'for' loops (ie. i or item or file)
#            these must also be declared to be local or when you make a call to another
#            function within your loop, you may find that you experience some strange
#            behaviour (eg. your loop cycles endlessly, misses items etc)
#            When used in a function, 'declare' (a bash builtin) creates local
#            variables by default. See http://www.ss64.com/bash/declare.html
#
#            Special cases are the global 'OPTIND' which is used by the getopts
#            function, and other bash things like IFS. We should not declare these local.
# RULE #5 :  the equality operator for a test ( if [ USED HERE ] ...) is '=', NOT '=='.
#            see man test for other info
#
# sync           - perform a complete backup (unfinished)
# sync_push      - rsync files to a server 
# sync_pull      - rsync files from a server 
# version        - operating system version info
# log            - redirect command output to a file (and keep on 
#                  printing to the console) (unfinished)
# read_password  - silently read and then echo the password
# nuke           - delete files by name pattern. 
# junk           - FIXME: not finished. find and remove junk files
#                  [operates in the current directory]
# repl           - replace "old text" "new text" '*.java'  
#                  [operates in the current directory]
# diff_dir       - find missing files betwen directories (unfinished)
# ask            - ask a question with a boolean/yes-no answer
# dump           - execute the given command and send output from it to a log file
# calc           - simple calculator
# round          - round a floating point number
# check_file     - test if a file exists, die on error
# check_dir      - test if a directory exists, die on error
# check_program  - test if an executable exists on your PATH, die on error
# unpack         - unpack a tar.gz with a progress bar
# unpack_all     - use unpack to unpack all tar.gz files in the current directory
# toLowercase    - convert all files in the working directory
#                  to lowercase. this function should be able to handle
#                  paths with newlines 
# reverse        - reverse the letters in the given string and print it
# classpath      - add all files in a directory to your classpath
# progress_spin  - a spinning icon, used for processes with an indeterminate running time
# run            - run a command and print a message and spinner til it completes
# or_die         - print an error and exit
# dos2unix       - convert line ending from dos to unix
# pem2crt        - convert PEM Certificate to ca-bundle.crt format
# pem2crtForBSD  - as above but for BSDs version of sed, which Mac OSX also uses.
# mount_iso      - mount an iso disc image
# split          - split a large file into smaller chunks
#
# Mac OS X ONLY
# ======================================================================================== 
# dmg2iso            - convert Mac Disk Image to an ISO image
# mount_dmg          - mount a dmg image
# burn               - burn a disk image file 
# launch_daemon      - (add and run) or (stop and remove) a launchd daemon
# add_recent_stack   - Adds a Recent items Stack to the Dock 
# remove_alias_badge - Removes the little arrow badge that is added to icons for aliases
# set_login_screen_background - Changes the background
# enable_time_machine_disks - Enables 'unsupported' disks
#
# Array Functions
# ======================================================================================== 
# A set of functions to simulate an associative array. The associative
# array is stored as a string in any variable. Both, key and value are
# encoded not to contain single vertical bars. Instead vertical bars
# are encoded as "|." A key/value pair is encoded like "||key|=value"
# and in addition, the whole string is terminated by "||".
#
# array_put      -
# array_get      -
# array_keys     -
# array_remove   -
#

# not finished yet
#function _split(){
#You can also pipe to the unix command “split” instead of directly outputting to a file
#svnadmin dump /var/lib/svn/repositories/repo_name | split -b 700m - mysvnproj.dump.tar.gz
#This will give you 700 megabyte tar.gz files with the extension “tar.gzaa”, “tar.gzab”, etc. (note the space dash space to read from the pipe) You can add an extra dot if you want. Then, at your other server:
#cat mysvnproj.dump.tar.gz* | svnadmin load /var/lib/svn/repositories/repo_name
#}

# usage: collect_password
function collect_password(){
    
    if [ -n "${SUDO_PASSWORD}" ]
    then
	log "Using existing stored password"
	
    else
	if ask -y "Would you like to store a password to be used for sudo commands?"
	then
	    local pass=`read_password "Enter password: "`
	    export SUDO_PASSWORD="${pass}"
	# just to get the newline
	    echo
	fi
    fi
}

# usage: newPass=`read_password "Enter new MySQL root password: "`
function read_password(){

stty -echo   # turn off the keyboard printing
read -p "[INFO] ${1}" passw;
stty echo    # turn it back on again
echo -n "${passw}"
}


function junk(){

echo "junk function is not completed"
#turn on calculate all sizes (, wait for a few minutes) and then sort by size

#/Library/Application Support
#/Library/Application Support/[iMovie,iDvD,Garage Band]
#/Library/Audio[/Apple Loops]
#/Library/Printers

#~/Library/Application Support
#~/Library/Logs/[little snitch]
#~/Library/Mail Downloads
#~/Library/Caches/Quicktime/downloads
}

function unpack(){
log "Extracting archive [`basename ${1}`]"
local UNPACK="progress_bar ${1} | tar zxvf - > /dev/null"
eval "${UNPACK}"
}

function unpack_this_dir(){
log "Unpacking archives in this directory."
local file
for file in ./*.tar.gz
do
 unpack "${file}"
done
}


function dump()
{

if [ ! $# -eq 1 ]
then
    log
    log "Usage:"
    log "dump [command] "
    log
    log "For Example:"
    log "dump mvn"
    log
    return 1 
fi

# create a new FD, 3, and point it to the same place FD 1 is pointed
exec 3>&1 

local DUMP_FILE=${1}_out.log
if [[ -e "${DUMP_FILE}" ]]
then
    log "Removing old log [${DUMP_FILE}]";
    rm "${DUMP_FILE}"
fi

log "Executing ${1} "

# Now, redirect FD 1 to point to the log file.
exec 1>"${DUMP_FILE}"

# EXECUTE THE COMMAND
eval "${1}" &
progress_spin $!

# Reset FD 1 to point to the same place as FD 3
exec 1>&3
log -d "Finished executing ${1}"


}

with-temp-file ()
{
    local _prefix=$1; shift
    local _tmpfile_var=$1 ; shift
    local ${_tmpfile_var}=$(mktemp -t ${_prefix})
    eval local _tmpfile_value=\${$_tmpfile_var}
    eval "$@"
    rm ${_tmpfile_value}
}

edlo ()
{
    with-temp-file "edlo" tmpfile \
        '$(tail -1 $HISTFILE) > $tmpfile && $EDITOR $tmpfile'
}

eoo () 
{ 
    local _cmd="$@";
    with-temp-file "eoo" tmpfile '$_cmd > $tmpfile && $EDITOR $tmpfile'
}


# Run a command with a spinner instead of a progress bar, for
# use with processes that take an indeterminate amount of time to complete
#
# usage: run [command] [message]
function run(){

local file
# MUST RESET OPTIND
OPTIND=1
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX
declare -a TRAILING_ARGS
local TOTAL_ARG_COUNT=0
local TRAILING_ARG_COUNT=0
local isSudo="off"
local isVerbose="off"
# sometimes we want to execute a command, that may return
# a return code > 0, but we still want it to be OK.
local isAlwaysOK="off"
while getopts "svK" flag
do
    case "$flag" in
      s)  isSudo=on;;
      v)  isVerbose=on;;
      K)  isAlwaysOK=on;;
      \?) die "Unrecognized option \?"
    esac
done


# ---------------------------------------------------
# FIND Command and Message
# ---------------------------------------------------
let LAST_OPTION=${OPTIND}
let LAST_OPTION--

let LAST_OPTION_IDX=LAST_OPTION
let LAST_OPTION_IDX--


if [ $# -gt ${LAST_OPTION_IDX} ]
then
   for file in "$@"
   do
    if [ ${TOTAL_ARG_COUNT} -gt ${LAST_OPTION_IDX} ]
    then
	log -t "Adding file ${file} to backup list"
        TRAILING_ARGS[TRAILING_ARG_COUNT]="${file}"

	let TRAILING_ARG_COUNT++
    fi

    let TOTAL_ARG_COUNT++
   done
fi 

if [ ${TRAILING_ARG_COUNT} -lt 2 ]
then
    die "Usage: run [command] [message]"
    return 1;
fi


local MESSAGE="${TRAILING_ARGS[1]}"

if [ "${isSudo}" = "on" ]
then
    # we do a dummy sudo here that will still be active when the command 
    # below executes
    if [ -n "${SUDO_PASSWORD}" ]
    then
	if [ "${isVerbose}" = "on" ]
	then
	    log "Using stored password "
	fi
	echo "${SUDO_PASSWORD}" | sudo -S touch . > /dev/null  2>&1
    else
	sudo ls > /dev/null
    fi
fi


if [ "${isVerbose}" = "on" ]
then
    log "Executing [${TRAILING_ARGS[0]}] [sudo: ${isSudo}]"
fi

#log "Executing [${TRAILING_ARGS[0]}]"
#log -n "${MESSAGE}"
#eval "(echo '${SUDO_PASSWORD}' | sudo -S ${TRAILING_ARGS[0]} && ok) || (fail && die \"Command failed $?\") &"; progress_spin $!;
#else

    log -n "${MESSAGE} "
    local HIDE_OUTPUT=" >/dev/null 2>&1 "
    #if [ "${isVerbose}" = "on" ]
    #then
    #   HIDE_OUTPUT=" >/dev/null 2>&1 "
    #fi
	
    local COMMAND="(${TRAILING_ARGS[0]} ${HIDE_OUTPUT} && ok) || (fail && die \"Command failed $?\") &"
    local COMMAND_OK="(${TRAILING_ARGS[0]}  ${HIDE_OUTPUT}) &"
    local SUDO_COMMAND="(echo '${SUDO_PASSWORD}' | sudo -S ${TRAILING_ARGS[0]} ${HIDE_OUTPUT} && ok) || (fail && die \"Command failed $?\") &"
    local SUDO_COMMAND_OK="(echo '${SUDO_PASSWORD}' | sudo -S ${TRAILING_ARGS[0]} ${HIDE_OUTPUT} ) &"

    if [ "${isSudo}" = "on" ]
    then
	eval "${SUDO_COMMAND}"; progress_spin $!;
    else
	eval "${COMMAND}"; progress_spin $!;
    fi

#    if [ "${isAlwaysOK}" = "on" ]
#    then
#	if [ "${isSudo}" = "on" ]
#	then
#            eval "${SUDO_COMMAND_OK}"; progress_spin $!;   
#	    ok
#	else
#            eval "${COMMAND_OK}"; progress_spin $!;   
#	    ok
#	fi
#    else
#	if [ "${isSudo}" = "on" ]
#	then
#	    log -n "Is SUDO"
#	    eval "${SUDO_COMMAND}"; progress_spin $!;
#	else
#	    eval "${COMMAND}"; progress_spin $!;
#	fi
#    fi
#fi

}

## This is similar to what FreeBSD does when it is booting
### some command &
### progress_spin $!
# A small "asterik" like thing will spin until the process is complete
#+ (when ps ax | grep PID no longer finds anything)
function progress_spin()
{
  ## The characters to use
  # These will be overlapped via ^H
  ICON[0]="/"
  ICON[1]="-"
  ICON[2]="\\"
  ICON[3]="|"

  ## The process we wish to monitor
  local PROCESS=$1

  ## Initialize count value
  # print out first icon
  local icon_num=0
#  log -n ${ICON[$icon_num]}

  ## While the process exists in ps ax, do this loop
  while ( ps ax | grep $PROCESS | grep -v "grep" 1>/dev/null )
  do
    ## If our count is bigger than 3 (our highest number icon)
    # reset it to 0
    if [ "$icon_num" -gt "3" ]; then
	icon_num=0
    fi

    set_color 31 40
    ## new_icon
    echo -en "${ICON[$icon_num]}"
    # backspace once
    printf  "\b"
    icon_num=`expr $icon_num + 1`

    sleep 0.5
    reset_color
  done

  return $?
}

# PRINT OUT SYSTEM INFO
function version(){
log "Kernel: `uname -s -r `"
log "Release: `uname -v`"
log "Machine [`uname -n`]: `uname -m -p`"
log "Platform: `uname -i -o` "
}

# Add a recent items Stack to the Dock (Mac OS X Leopard)
# you can control click the dock icon to select between recent applications, documents, servers ec.
function add_recent_stack(){

# this command adds a recent-things stack to the mac osx 5 (leopard) dock
defaults write com.apple.dock persistent-others -array-add '{ "tile-data" = { "list-type" = 1; }; "tile-type" = "recents-tile"; }'

# this command is the same as the first but puts it in the other side of the dock 
#defaults write com.apple.dock persistent-apps -array-add '{ "tile-data" = { "list-type" = 1; }; "tile-type" = "recents-tile"; }'

# just restart the dock
killall Dock

}

# Removes the little arrow badge that is added to icons for aliases
function remove_alias_badge(){
cd /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources
mv AliasBadgeIcon.icns AliasBadgeIcon_DISABLED.icns

}

function enable_time_machine_disks(){
defaults write com.apple.systempreferences TMShowUnsupportedNetworkVolumes 1
}

function backup_codebase() {

    if ask -y "About to create an encrypted codebase disc, continue?"
	then

	local BACKUP_NAME=codebase_`date +%d%b%Y-%H-%M-%S`
	local ENCRYPTED_CD_NAME="encrypted_${BACKUP_NAME}"

backup -k -n "${BACKUP_NAME}" -f "${BACKUP_NAME}" ~/.m2/settings.xml ~/Development/keys ~/Development/codebase
backup -b -n "${ENCRYPTED_CD_NAME}" -f "${ENCRYPTED_CD_NAME}" "${BACKUP_NAME}.sparseimage"
    fi
}

# Adds or removes a launch daemon
# - using just -r option will stop and unload the given daemon name and the return
# - using just -a will just add and start the daemon
# - using both -a and -r, the function will stop and unload, than add a new daemon
function launch_daemon(){

# MUST RESET OPTIND
OPTIND=1
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX

local WORKING_DIR="/tmp"
local DAEMON_USER=NONE
local DAEMON_NAME=NONE
local EXECUTABLE=NONE
local EXECUTABLE_ARGUMENTS=NONE
local INSTALL_LOCATION=NONE
local DATA_LOCATION=NONE
local DATA_PERMISSIONS=0777
local IS_ADD="off"
local IS_REMOVE="off"

while getopts "aD:ru:n:e:d:t:p:" flag
do
    case "$flag" in
      a)  IS_ADD="on";;
      r)  IS_REMOVE="on";;
      D)  EXECUTABLE_ARGUMENTS="${OPTARG}";;
      u)  DAEMON_USER="${OPTARG}";;
      n)  DAEMON_NAME="${OPTARG}";;
      e)  EXECUTABLE="${OPTARG}";;
      d)  INSTALL_LOCATION="${OPTARG}";;
      t)  DATA_LOCATION="${OPTARG}";;
      p)  DATA_PERMISSIONS="${OPTARG}";;
      \?) die "Unknown option"
          return 1;;
    esac
done

if [ "${DAEMON_NAME}" = "NONE" ]
then
    die "You need to specify a daemon name, with the -n [name] option."
    return 1;
fi


if [ "${IS_REMOVE}" = "on" ]
then

    run -s -K "launchctl stop ${DAEMON_NAME}" \
	      "Stopping any existing ${DAEMON_NAME} daemons"
    run -s "launchctl -v unload /Library/LaunchDaemons/${DAEMON_NAME}.plist" \
	      "Unloading ${DAEMON_NAME}.plist"


    if [ "${INSTALL_LOCATION}" != "NONE" ]
    then
	if [ -e "${INSTALL_LOCATION}" ]
	then
	    if ask -y "Directory [${INSTALL_LOCATION}] exists, should i delete it?."
	    then
		rm -rf "${INSTALL_LOCATION}"
	    else   
		die "Please choose a different install location, sing the -d [my_dir] option"
	    fi
	fi
	
    fi


    if [ "${DATA_LOCATION}" != "NONE" ]
    then
	if [ -e "${DATA_LOCATION}" ]
	then
	    if ask -y "Directory [${DATA_LOCATION}] exists, should i delete it?."
	    then
		rm -rf "${DATA_LOCATION}"
	    else   
		die "Please choose a different data location, using the -t [my_dir] option"
	    fi
	fi
	
    fi

    if [ "${IS_ADD}" = "off" ]
    then
	return $?;
    fi
fi

if [ "${INSTALL_LOCATION}" = "NONE" ]
then
    die "You need to specify the installation directory, with the -d [full path] option."
    return 1;
fi


if [ "${DATA_LOCATION}" = "NONE" ]
then
    die "You need to specify the installation directory, with the -t [full path] option."
    return 1;
fi

if [ "${EXECUTABLE}" = "NONE" ]
then
    die "You need to specify an executable, with the -e [full path to executable] option."
    return 1;
fi

if [ "${DAEMON_USER}" = "NONE" ]
then
    die "You need to specify a daemon user, with the -u [username] option."
    return 1;
fi

check_dir "${WORKING_DIR}"

log -d "Creating launchd item ${WORKING_DIR}/${DAEMON_NAME}.plist"
cat > "${WORKING_DIR}/${DAEMON_NAME}.plist" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<!-- If true, this key means the daemon will be restarted every time you kill it -->
	<key>KeepAlive</key>
	<false/>
	<key>Label</key>
	<string>DAEMON_NAME</string>
	<key>Program</key>
	<string>EXECUTABLE</string>
        <key>ProgramArguments</key>
        <array>
          <string>EXECUTABLE_ARGUMENTS</string>
        </array>
	<key>RunAtLoad</key>
	<false/>
	<key>Debug</key>
	<true/>
	<key>UserName</key>
	<string>DAEMON_USER</string>
	<key>WorkingDirectory</key>
	<string>INSTALL_LOCATION</string>
	<key>StandardOutPath</key>
	<string>INSTALL_LOCATION/launch.out</string>
	<key>StandardErrorPath</key>
	<string>INSTALL_LOCATION/launch.err</string>
</dict>
</plist>
EOF

repl -q -s -d "${WORKING_DIR}" "EXECUTABLE_ARGUMENTS"  "${EXECUTABLE_ARGUMENTS}" '*.plist'
repl -q -s -d "${WORKING_DIR}" "EXECUTABLE"  "${EXECUTABLE}" '*.plist'
repl -q -s -d "${WORKING_DIR}" "DAEMON_USER" "${DAEMON_USER}" '*.plist'
repl -q -s -d "${WORKING_DIR}" "DAEMON_NAME" "${DAEMON_NAME}" '*.plist'
repl -q -s -d "${WORKING_DIR}" "INSTALL_LOCATION" "${INSTALL_LOCATION}" '*.plist'


if [ "${IS_ADD}" = "on" ]
then

    run -s "chown -R ${DAEMON_USER} ${DATA_LOCATION}" "Setting ownership for data location"
    run -s "chmod -R ${DATA_PERMISSIONS} ${DATA_LOCATION}" "Setting permissions for data location"

    run -s "cp \"${WORKING_DIR}/${DAEMON_NAME}.plist\" /Library/LaunchDaemons" \
           "Copying ${DAEMON_NAME}.plist"
    run -s "chown root /Library/LaunchDaemons/${DAEMON_NAME}.plist" \
	   "Setting ownership for daemon"
    run -s "chmod 0644 /Library/LaunchDaemons/${DAEMON_NAME}.plist" \
	   "Setting permissions for daemon"
    run -s "launchctl -v load /Library/LaunchDaemons/${DAEMON_NAME}.plist" \
	   "Loading ${DAEMON_NAME} daemon"   
    run -s "launchctl start ${DAEMON_NAME}" \
	   "Launching ${DAEMON_NAME} daemon"   

else
    log -w "You did not specify an operation for launch_daemon."
    log -w "Use -a to add a daemon, or -r to remove"
fi
}

function mount_iso(){

check_file "${1}"

local MOUNT_POINT=`file_info -n "${1}"`
mkdirWithRetry "${MOUNT_POINT}"

# Mount the Development Disk Image 
mount -o loop -t iso9660 "${1}" "${MOUNT_POINT}"

if [ $? -ne 0 ]
then
log -e "Unable to mount disk image [${1}], hdiutil returned [$?]"
return $?
fi

}

function mount_dmg(){

check_file "${1}"
      
# Mount the Development Disk Image 
hdiutil attach "${1}" > /dev/null

if [ $? -ne 0 ]
then
log -e "Unable to mount disk image [${1}], hdiutil returned [$?]"
return $?
fi

}

function dmg2iso() {

# MUST RESET OPTIND
OPTIND=1
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX

local BE_VERBOSE=off

declare -a IMAGE_FILES

while getopts "v" flag
do
    case "$flag" in
      v)  BE_VERBOSE=on;;
      \?) dmg2iso_usage
          return 1;;
    esac
done

let LAST_OPTION=${OPTIND}
let LAST_OPTION--

let LAST_OPTION_IDX=LAST_OPTION
let LAST_OPTION_IDX--

# ---------------------------------------------------
# FIND ISO and dmg
# ---------------------------------------------------
local file
local count=0
local FILE_COUNT=0
if [ $# -gt ${LAST_OPTION_IDX} ]
then
   for file in "$@"
   do
    #log you typed ${file} ${count}.
    if [ $count -gt ${LAST_OPTION_IDX} ]
    then
	log -t "Adding file ${file} to backup list"
        IMAGE_FILES[FILE_COUNT]="${file}"

	let FILE_COUNT++
    fi

    let count++

   done

fi 

# ---------------------------------------------------
# FIND LIST OF FILES TO BE BACKED UP
# ---------------------------------------------------
if [ ${FILE_COUNT} -ne 2 ]
then
    log -e "Image files not specified correctly."
    dmg2iso_usage
    return 1;
fi

if [ ! -f ${IMAGE_FILES[0]} ]
then
    log -e "DMG Image file [${IMAGE_FILES[0]}] does not exist"
    dmg2iso_usage
    return 1;
fi

if [ -f ${IMAGE_FILES[1]} ]
then
    log -e "Target ISO Image file [${IMAGE_FILES[1]}] already exists"
    dmg2iso_usage
    return 1;
fi

TARGET_DIR=`dirname ${IMAGE_FILES[1]}`
if [ ! -d ${TARGET_DIR} ]
then
    mkdirWithRetry ${TARGET_DIR}
fi

hdiutil convert ${IMAGE_FILES[0]} -format UDTO -o ${IMAGE_FILES[1]}
or_die " Unable to convert [${IMAGE_FILES[0]}] to [${IMAGE_FILES[1]}] [$?]"

}

function dmg2iso_usage(){
    log "dmg2iso [path to dmg file] [path to iso file]"
}

# Convert PEM Certificate to ca-bundle.crt format
function pem2crt(){
# !/bin/sh
# Friendly Name
openssl x509 -in $1 -text -noout | sed -n -e '/^[ ]\+Subject:/{s/^.*CN=\([^,]*\).*/\1/;p}' 
# Underline Friendly Name with equal signs
openssl x509 -in $1 -text -noout | sed -n -e '/^[ ]\+Subject:/{s/^.*CN=\([^,]*\).*/\1/;p}' | sed -e 's/./=/g'
# Output Fingerprint and swap = for :
openssl x509 -in $1 -noout -fingerprint | sed -e 's/=/: /'
# Output PEM Data:
log 'PEM Data:'
# Output Certificate
openssl x509 -in $1
# Output Cettificate text swapping Certificate with Certificate Ingredients
openssl x509 -in $1 -text -noout | sed -e 's/^Certificate:/Certificate Ingredients:/'
}

#
# Convert PEM Certificate to ca-bundle.crt format
#
# Now this work with *BSD sed as well. fix by komar 
function pem2crtForBSD(){

test ! $1 && printf "Usage: `basename $0` certificate" && exit 1 

# Friendly Name and Underline Friendly Name with equal signs
openssl x509 -in $1 -text -noout | sed -e 's/^  *Subject:.*CN=\([^,]*\).*/\1/p;t  c' -e 'd;:c' -e 's/./=/g'                                           
# Output Fingerprint and swap = for :
openssl x509 -in $1 -noout -fingerprint | sed -e 's/=/: /'
# Output PEM Data:
log 'PEM Data:'
# Output Certificate
openssl x509 -in $1
# Output Cettificate text swapping Certificate with Certificate Ingredients
openssl x509 -in $1 -text -noout | sed -e 's/^Certificate:/Certificate Ingredients:/'
}

# @fixme doesn't seem to be working properly - only one diff is found
# @fixme make the temp file names an option
function diff_dir(){
# diff -qr "${1}" "${2}" | grep -v -e 'DS_Store' -e 'Thumbs' | sort 

SCRIPT="diff_dir"
FILELIST=/tmp/$SCRIPT.list$$
DIFFS=/tmp/$SCRIPT.diffs$$
BADUSAGE="Type \"$SCRIPT -h\" for command usage."

EXCLUDE_LIST=
EXCLUDE_DIRLIST=
BINARY=false
IGNORECR=false
IGNOREEXIST=false
LISTONLY=false
QUIET=false
RECURSIVE=false
SHOWLEFT=false
SHOWRIGHT=false
IGNORETEXT=false
DIFFOPTS=
CMPOPTS=

OPTIND=1
while getopts bBce:E:hlqrLRTX switch; do
   case "$switch" in
   b)
DIFFOPTS="$DIFFOPTS -b"
;;
   B)
BINARY=true
;;
   c)
IGNORECR=true
;;
   e)
EXCLUDE_LIST="$EXCLUDE_LIST $OPTARG"
;;
   E)
       EXCLUDE_DIRLIST="$EXCLUDE_DIRLIST $OPTARG"
    ;;
   h)
log "$SCRIPT -- Compare files in two directories."
log "Usage: $SCRIPT [options] leftdir rightdir"
log "Options:"
log "   -b        ignore trailing blanks"
log "   -B        include comparison of binary files"
log "   -c        ignore trailing carriage returns"
log "   -e file   exclude file from comparison"
log "   -E dir    exclude subdirectory from comparison"
log "   -l        list filenames only"
log "   -q        quiet mode (only list filename if there are differences)"
log "   -r        recursive mode (descend all subdirectories)"
log "   -L        show contents of files that only exist in leftdir"
log "   -R        show contents of files that only exist in rightdir"
log "   -T        ignore files that are text in one directory"
log "   -X        ignore files that only exist in one directory"
exit 0
;;
   l)
LISTONLY=true
QUIET=true
;;
   q)
QUIET=true
;;
   r)
RECURSIVE=true
;;
   L)
SHOWLEFT=true
;;
   R)
SHOWRIGHT=true
;;
   T)
IGNORETEXT=true
;;
   X)
IGNOREEXIST=true
;;
   \?)
log "$BADUSAGE" >&2
exit 1
;;
   esac
done
shift `expr $OPTIND - 1`

if [ $# -ne 2 ]; then
   log "$BADUSAGE" >&2
   exit 1
elif [ ! -d "$1" ]; then
   log "Invalid directory: $1" >&2
   log "$BADUSAGE" >&2
   exit 1
elif [ ! -d "$2" ]; then
   log "Invalid directory: $2" >&2
   log "$BADUSAGE" >&2
   exit 1
fi

cdir=`pwd` # current directory
cd "$2"
rdir=`pwd` # right directory
cd "$cdir"
cd "$1"
ldir=`pwd` # left directory

if [ "$ldir" = "$rdir" ]; then
   exit 0
fi

NODIRS=`(for name in $EXCLUDE_DIRLIST; do
   find "$ldir" -name "$name" -type d -print | sed "s;^$ldir/;;"
   find "$rdir" -name "$name" -type d -print | sed "s;^$rdir/;;"
done) | sort | uniq`

if $RECURSIVE; then
   (
find "$ldir" -type f -print | sed "s;^$ldir/;;"
find "$rdir" -type f -print | sed "s;^$rdir/;;"
   ) | sort | uniq >"$FILELIST"
else
   (
'ls' -a1 "$ldir" | while read f; do
    if [ ! -d "$ldir/$f" ]; then
        log "$f"
    fi
done
'ls' -a1 "$rdir" | while read f; do
    if [ ! -d "$rdir/$f" ]; then
        log "$f"
    fi
done
   ) | sort | uniq >"$FILELIST"
fi

local exclude
local doexclude
local dir
while read f; do
   if [ -n "$EXCLUDE_LIST" ]; then
doexclude=false
for exclude in $EXCLUDE_LIST; do
    if [ "`basename \"$f\"`" = "$exclude" ]; then
 doexclude=true
 break
    fi
done
if $doexclude; then
    continue
fi
   fi

   if [ -n "$NODIRS" ]; then
       doexclude=false
       for dir in $NODIRS; do
           quit=`expr "$f" : "$dir"`
           if [ $quit -gt 0 ]; then
               doexclude=true
               break
           fi
       done
       if $doexclude; then
    continue
       fi
   fi

   lfile="$ldir/$f"
   rfile="$rdir/$f"
   if [ -f "$lfile" ]; then
if [ -f "$rfile" ]; then
    if file "$lfile" | grep "text\$" >/dev/null; then
 if file "$rfile" | grep "text\$" >/dev/null; then
     if $IGNORECR; then
  lfile=/tmp/$SCRIPT.lfile$$
  sed "s;
*$;;" "$ldir/$f" >"$lfile"
  rfile=/tmp/$SCRIPT.rfile$$
  sed "s;
*$;;" "$rdir/$f" >"$rfile"
     fi
     if $QUIET; then
  diff $DIFFOPTS "$lfile" "$rfile" >"$DIFFS"
  if [ -s "$DIFFS" ]; then
      if $LISTONLY; then
   log "$f"
      else
   log "FILE: $f"
   cat "$DIFFS"
      fi
  fi
     else
  log "FILE: $f"
  diff $DIFFOPTS "$lfile" "$rfile"
     fi
     if $IGNORECR; then
  rm -f "$lfile" "$rfile"
     fi
 else
     if $IGNORETEXT; then
  continue
     elif $LISTONLY; then
  log "$f"
     else
  log "FILE: $f is not a text file in $rdir"
     fi
 fi
    elif file "$rfile" | grep "text\$" >/dev/null; then
 if $IGNORETEXT; then
     continue
 elif $LISTONLY; then
     log "$f"
 else
     log "FILE: $f is not a text file in $ldir"
 fi
    elif $BINARY; then
 if $QUIET; then
     cmp $CMPOPTS "$lfile" "$rfile" >"$DIFFS"
     if [ -s "$DIFFS" ]; then
  if $LISTONLY; then
      log "$f"
  else
      log "FILE: $f"
      cat "$DIFFS"
  fi
     fi
 else
     log "FILE: $f"
     cmp $CMPOPTS "$lfile" "$rfile"
 fi
    fi
else
    if $IGNOREEXIST; then
 continue
    elif $LISTONLY; then
 log "$f"
    else
 log "FILE: $f does not exist in $rdir"
 if $SHOWLEFT; then
     if file "$lfile" | grep "text\$" >/dev/null; then
  cat "$lfile" | sed "s;^;<;;"
     fi
 fi
    fi
fi
   else
if $IGNOREEXIST; then
    continue
elif $LISTONLY; then
    log "$f"
else
    log "FILE: $f does not exist in $ldir"
    if $SHOWRIGHT; then
 if file "$rfile" | grep "text\$" >/dev/null; then
     cat "$rfile" | sed "s;^;>;;"
 fi
    fi
fi
   fi
done <"$FILELIST"

rm -f "$FILELIST" "$DIFFS"

}

function copyWithRetry(){

    if [ ! $# -eq 1 ]
	then
	log
	log "Usage:"
	log "copyWithRetry [file or directory path] "
	log
	log "For Example:"
	log "copyWithRetry /my/path/to/file.txt "
	log
	return 1 
    else
      if [ -e ${1} ]
	  then
	  FILE_OR_DIRECTORY=${1}
      else
	  log -e "File [${1}] does not exist. "
	  return 1
      fi
    fi


  log "Please enter the absolute path of the directory to copy :"
  read -e NEW_LOC

  if [ -d ${NEW_LOC} ]
  then
      log -n "[INFO] Copying ${FILE_OR_DIRECTORY} to ${NEW_LOC} ..."

      if [ -d ${FILE_OR_DIRECTORY} ]
	  then
	  cp -R ${FILE_OR_DIRECTORY} ${NEW_LOC}
      else
	  cp ${FILE_OR_DIRECTORY} ${NEW_LOC}
      fi	  
      log_result
	  
      if [ ! -d ${FILE_OR_DIRECTORY} ]
	  then
	  log -n "[INFO] Verifying ${NEW_LOC}/${FILE_OR_DIRECTORY} ..."
	  ORIG=`md5 ${FILE_OR_DIRECTORY}`
	  NEWIMG=`md5 ${NEW_LOC}/${FILE_OR_DIRECTORY}`
      
	  if [ ${ORIG} = ${NEWIMG} ]
	      then
	      ok
	  else
	      fail
	  fi
      fi

  else
      log "Directory [${NEW_LOC}] does not exist, try again."
      copyWithRetry ${FILE_OR_DIRECTORY}
  fi

}


function mkdirWithRetry(){

    if [ ! $# -eq 1 ]
	then
	log
	log "Usage:"
	log "mkdirWithRetry [directory path] "
	log
	log "For Example:"
	log "mkdirWithRetry /my/path/to/dir "
	log
	return 1 
    else
      if [ -d ${1} ]
	  then
	  log "Directory [${1}] already exists. "
	  return 0
      elif [ -f ${1} ]
	  then
	  log -e "File [${1}] already exists. "
	  return 1
      else
	  TARGET_DIRECTORY=${1}
      fi
    fi

  PARENT_DIRECTORY=`dirname ${TARGET_DIRECTORY}`
  TARGET_DIRECTORY_NAME=`basename ${TARGET_DIRECTORY}`

  if [ -d ${PARENT_DIRECTORY} ]
  then
      log -n "[INFO] Making directory [${TARGET_DIRECTORY_NAME}] in [${PARENT_DIRECTORY}] ..."

      mkdir ${TARGET_DIRECTORY}
      log_result
  else
      if ask -y "Directory [${PARENT_DIRECTORY}] does not exist, should i make it?."
	  then
	  OLD_TARGET=${TARGET_DIRECTORY}
	  mkdirWithRetry ${PARENT_DIRECTORY}
	  TARGET_DIRECTORY=${OLD_TARGET}
	  log "Retrying ${TARGET_DIRECTORY}"
	  mkdirWithRetry ${TARGET_DIRECTORY}
      fi
	  
  fi

}


function classpath(){

    if [ ! $# -eq 1 ]
	then
	log
	log "Usage:"
	log "classpath [directory path] "
	log
	log "For Example:"
	log "classpath /my/path/to/lib/dir "
	log
	return 1 
    else
      if [ -e ${1} ]
	  then
	  log "Adding all jars in ${1} to the CLASSPATH"
      else
	  log -e "File [${1}] does not exist. "
	  return 1
      fi
    fi

    local JAR_FILE
    for JAR_FILE in `find ${1} -type f -name \*.jar`
      do
      log "Adding ${JAR_FILE}"

      IS_CP_SET=${CLASSPATH:-NOTSET}
      if [ ${IS_CP_SET} = "NOTSET" ]
	  then
	  export CLASSPATH="${JAR_FILE}"
      else
	  export CLASSPATH="${CLASSPATH}":${JAR_FILE}
      fi
    done

}

function isset(){

# This script tests whether a variable is set. If not,
# it exits printing a message.

log ${1:?"There's so much I still wanted to do..."}
log "VAR is set, we can proceed."
}

### usage: calc <math expression>
### multiplication needs escape: \*
# FIXME: we removed the sed that trims the trailing zeros b/c
#        it was returning 14 instead of 140
#        we still need this functionality, but just for zeros
#        after the point
function calc {

# sed info: trim trailing 0s, trim trailing period, is this zero?
#bc -l <<< $@ | sed -e "s:0*$::" -e "s:\.$::" -e "s:^$:0:"
bc -l <<< $@ 
}

function round() {
INT=$(printf "%1.0f" $1)
NEAREST=${2:-10}

while ((INT % NEAREST)); do
   let INT++
done

log $INT

}


function reverse()
{
        string=$1
        len=$(log -n $string | wc -c)
        while test $len -gt 0
        do
                rev=$rev$(log $string | cut -c $len)
                len=$(( len - 1 ))
        done
        log $rev
}

function file_info(){

# MUST RESET OPTIND
OPTIND=1
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX

local DO_NAME=off
local DO_VERSION=off
local DO_NAME_AND_VERSION=off
local DO_EXTENSION=off
local SEPARATOR=.
while getopts "nNevS:" flag
do
    case "$flag" in
      n)  DO_NAME=on;;
      N)  DO_NAME_AND_VERSION=on;;
      v)  DO_VERSION=on;;
      e)  DO_EXTENSION=on;;
      S)  SEPARATOR=${OPTARG};;
      \?) log_usage
          return 1;;
    esac
done


let LAST_OPTION=${OPTIND}
let LAST_OPTION--

let LAST_OPTION_IDX=LAST_OPTION
let LAST_OPTION_IDX--
let FIRST_ARG_IDX=LAST_OPTION_IDX
let FIRST_ARG_IDX++

local item
local count=0
if [ $# -gt ${LAST_OPTION_IDX} ]
then
   for item in "$@"
   do
    #log you typed ${item} ${count}.
    if [ $count -gt ${LAST_OPTION_IDX} ]
    then
	    JUST_THE_FILE=`basename ${item}`
	    FILE_NAME=`echo "${JUST_THE_FILE}" | cut -d'-' -f1`
	    if [ "${DO_NAME_AND_VERSION}" != "on" ]
	    then
		if [ "${DO_NAME}" = "on" ]
		then
		    echo -n "${FILE_NAME}"
		    return
		fi
	    fi
	    VERSION_AND_EXTENSION=`echo "${JUST_THE_FILE}" | cut -d'-' -f2`
#echo "V&S is: ${VERSION_AND_EXTENSION}"
	    EXTENSION=`echo "${VERSION_AND_EXTENSION##*.}"`
#echo "EXT is: ${EXTENSION}"
	    VERSION=`echo "${VERSION_AND_EXTENSION%.*}"`
#echo "VERSION is: ${VERSION}"
	    if [ "${EXTENSION}" = "gz" ]
	    then
		NEXT_SEGMENT=`echo "${VERSION##*.}"`
		VERSION=`echo "${VERSION%.*}"`
		EXTENSION="${NEXT_SEGMENT}.${EXTENSION}"
	    fi
	    
	    if [ "${DO_VERSION}" = "on" ]
	    then
		echo -n "${VERSION}"
		return
	    fi

	    if [ "${DO_NAME_AND_VERSION}" = "on" ]
	    then
		echo -n "${FILE_NAME}-${VERSION}"
		return
	    fi
	    
	    if [ "${DO_EXTENSION}" = "on" ]
	    then
		echo -n "${EXTENSION}"
		return
	    fi
	fi
    let count++
   done
else
die "No filename was supplied"
fi
}

# NOTE: if you have trouble burning, search bin/backup for 'detach'
function burn(){
log "Burning disk image"
hdiutil burn "${1}" -noverifyburn -noeject
or_die " Unable to burn disk image, hdiutil returned [$?]"
}


function or_die(){
if [ $? -ne 0 ]
then
  die "${1}"
fi
}

# right justified, 5 characters
function die(){
  echo -n "["
  local STYLE=0
  local FG=31
  local BG=40
  local CTRL="\033[${STYLE};${FG};${BG}m"
  echo -en "${CTRL}"
  printf "%5s" "ERROR"
  # reset
  echo -en "\033[0m"
  echo "] ${1}"
  exit $?
}

# right justified, 5 characters
function fail(){
  reset_color
  printf "%5s" "["
  print_red "FAILED"
  echo "]"
}

# right justified, 5 characters
function ok(){
  reset_color
  printf "%5s" "["
  print_green "OK"
  echo "]"
}

function log_result(){

if [ $? -ne 0 ]
then
    fail
    return $?
else
    ok
fi

}

# left justified, 50 characters
function log(){

# MUST MAKE i (and all counters) local
local i=0
# MUST RESET OPTIND
OPTIND=1
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX

local DEFAULT_THRESHOLD_LEVEL_NAME="INFO"
local MESSAGE_LEVEL_NAME="INFO"
local CMD_SPACING="%-67s"
local DO_NEWLINE=on

array_put LOG_LEVELS TRACE 0
array_put LOG_LEVELS DEBUG 1
array_put LOG_LEVELS INFO 2
array_put LOG_LEVELS WARN 3
array_put LOG_LEVELS ERROR 4
array_put LOG_LEVELS FATAL 5


while getopts "fewditS:n" flag
do
    case "$flag" in
      f)  MESSAGE_LEVEL_NAME=FATAL;;
      e)  MESSAGE_LEVEL_NAME=ERROR;;
      w)  MESSAGE_LEVEL_NAME="WARN";;
      i)  MESSAGE_LEVEL_NAME="INFO";;
      d)  MESSAGE_LEVEL_NAME=DEBUG;;
      t)  MESSAGE_LEVEL_NAME="TRACE";;
      n)  DO_NEWLINE=off;;
      S)  CMD_SPACING=${OPTARG};;
      \?) log_usage
          return 1;;
    esac
done

# Get the Message level
local MESSAGE_LEVEL=`array_get LOG_LEVELS ${MESSAGE_LEVEL_NAME}`

# Get the User's "LOG_LEVEL" environment level
local USER_LEVEL=`array_get LOG_LEVELS ${LOG_LEVEL}`
local DEFAULT_LEVEL=`array_get LOG_LEVELS ${DEFAULT_THRESHOLD_LEVEL_NAME}`
local THRESHOLD_LEVEL
let THRESHOLD_LEVEL=${USER_LEVEL:-${DEFAULT_LEVEL}}
 
if [ "${MESSAGE_LEVEL}" -lt "${THRESHOLD_LEVEL}" ]
then
return
fi

let LAST_OPTION=${OPTIND}
let LAST_OPTION--

let LAST_OPTION_IDX=LAST_OPTION
let LAST_OPTION_IDX--
let FIRST_ARG_IDX=LAST_OPTION_IDX
let FIRST_ARG_IDX++


# ---------------------------------------------------
# FIND LIST OF string ARGUMENTS
# ---------------------------------------------------
local count=0
local ARG_COUNT=0
local item
declare -a ADDITIONAL_ARGS

if [ $# -gt ${LAST_OPTION_IDX} ]
then
   for item in "$@"
   do
    #log you typed ${item} ${count}.
    if [ $count -gt ${LAST_OPTION_IDX} ]
    then
	if [ $count -gt ${FIRST_ARG_IDX} ]
	then
	   let zeroIndexed=${ARG_COUNT}
	   let zeroIndexed--
           #log "Adding arg ${item} to list, count: ${ARG_COUNT}, zero: ${zeroIndexed}"
           ADDITIONAL_ARGS[${zeroIndexed}]="${item}"
	else
	    #log "FIRST ARG IS ${item}"
	    FIRST_ARG="${item}"
	fi

	let ARG_COUNT++
    fi

    let count++
   done
fi


local MLC="${MESSAGE_LEVEL_NAME}"
local CMD_ARGS="\"[${MESSAGE_LEVEL_NAME}] ${FIRST_ARG}\""
local numArgs="${#ADDITIONAL_ARGS}"
for ((i=0;i<$numArgs;i++));  do
    CMD_ARGS="${CMD_ARGS}, \"${ADDITIONAL_ARGS[${i}]}\""
done

#echo -n "[ "
#print_color "${MLC}" 31 40
#echo -n "] "

local CMD="printf ${CMD_ARGS}"
#echo "${CMD}"
local CMD="printf \"${CMD_SPACING}\" ${CMD_ARGS}"
eval "${CMD}"
if [ "${DO_NEWLINE}" = "on" ]
then
echo ""
fi
}

function check_program() {
log -n "Checking for program [${1}]"
local PROG=`which ${1}`

if [ ! -f "${PROG}" ]
then
    fail
    die " Unable to find program [${1}] on your PATH [${PATH}] [$?]"
else
    ok
fi
}

function check_dir(){
 log -n "Checking for directory [${1}]"
if [ ! -d ${1} ]
then
    fail
    die " Unable to find directory [${1}]"
else
    ok
fi
}

function check_file(){
 log -n "Checking for file [${1}]"

 if [ ! -f ${1} ]
 then
     fail
     die " Unable to find file [${1}]"
 else
     ok
 fi

}


# ============================= STRING FXNS ====================================


# this fxn is from (http://download.gna.org/mbfl/1.0.6/mbfl.html#String%20Misc)
function mbfl_string_replace () {
local STRING=${1:?"missing string parameter to '${FUNCNAME}'"}
local PATTERN=${2:?"missing pattern parameter to '${FUNCNAME}'"}
local SUBST="${3:-}"
printf "${STRING//$PATTERN/$SUBST}\n"
}


function toLowercase() {
local filename
for filename in *    # Not necessary to use basename,
                     # since "*" won't return any file containing "/".
do n=`log "$filename/" | tr '[:upper:]' '[:lower:]'`
#                             POSIX char set notation.
#                    Slash added so that trailing newlines are not
#                    removed by command substitution.
   # Variable substitution:
   n=${n%/}          # Removes trailing slash, added above, from filename.
   [[ $filename == $n ]] || mv "$filename" "$n"
                     # Checks if filename already lowercase.
done

}

function print_red(){
print_color ${1} 31 40
}


function print_green(){
print_color ${1} 32 40
}

# ==================================DONE====================================

# usage: print_color [text] [foreground] [background]
function print_color(){
  local STYLE=0
  local FG="${2}"
  local BG="${3}"
  local CTRL="\033[${STYLE};${FG};${BG}m"
  echo -en "${CTRL}"
  printf "%1s" "${1}"
  # reset
  echo -en "\033[0m"
}


# usage: set_color [foreground] [background]
function set_color(){
  local STYLE=0
  local FG="${1}"
  local BG="${2}"
  local CTRL="\033[${STYLE};${FG};${BG}m"
  echo -en "${CTRL}"
}

function reset_color(){
  # reset
  echo -en "\033[0m"
}


function nuke_usage(){

    log
    log "Usage:"
    log "nuke [options] 'glob pattern' [list of target directories] "
    log
    log "For Example:"
    log "nuke '*semantic_cache* docs' "
    log

}

function nuke() {

# MUST RESET OPTIND
OPTIND=1
local i=0
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX

local FILES_ONLY=off
local DIRECTORIES_ONLY=off
local DEFAULT_DIR=`pwd`
declare -a TARGET_DIRECTORIES
local GLOB_PATTERN="NOTSPECIFIED"
local HAVE_TARGET="NOTSPECIFIED"
local BE_VERBOSE="off"
local TYPE

while getopts "vfd" flag
do
    case "$flag" in
      v)  BE_VERBOSE=on;;
      f)  FILES_ONLY=on;;
      d)  DIRECTORIES_ONLY=on;;
      \?) nuke_usage
          return 1;;
    esac
done

if [ ${FILES_ONLY} = "on" ]
    then
    TYPE=" -t f "
elif [ ${DIRECTORIES_ONLY} = "on" ]
    then
    TYPE=" -t d "
else
    TYPE=
fi 


let LAST_OPTION=${OPTIND}
let LAST_OPTION--

let LAST_OPTION_IDX=LAST_OPTION
let LAST_OPTION_IDX--

# ---------------------------------------------------
# FIND LIST OF FILES TO BE BACKED UP
# ---------------------------------------------------
local count=0
local FILE_COUNT=0
local file
if [ $# -gt ${LAST_OPTION_IDX} ]
then
   for file in "$@"
   do
    #log you typed ${file} ${count}.
    if [ $count -gt ${LAST_OPTION_IDX} ]
    then
	#log "before blah $count"
	if [ $count -lt 1 ]
	    then

	    # THE FIRST ARG IS THE GLOB PATTERN
	    GLOB_PATTERN=${file}
	    log "Pattern is ${GLOB_PATTERN}"
	else
	    HAVE_TARGET="TRUE"
	    log -t "Adding file ${file} to nuke list"
	    TARGET_DIRECTORIES[FILE_COUNT]="${file}"

	    let FILE_COUNT++
	fi
    fi

    let count++

   done
fi


if [ ${GLOB_PATTERN} = "NOTSPECIFIED" ]
then
    nuke_usage
    return 1
fi

if [ ${HAVE_TARGET} = "NOTSPECIFIED" ]
then
    log "No directories specified, will use current dir [${DEFAULT_DIR}]"
    TARGET_DIRECTORIES[0]=${DEFAULT_DIR}
    let FILE_COUNT++
fi 


ORIGINAL_IFS=$IFS
IFS=$'\n'
for ((i=0;i<$FILE_COUNT;i++)); do
   
   local DIR="${TARGET_DIRECTORIES[${i}]}"
   log "Processing next directory [${DIR}]"
   if [ ! -e ${DIR} ]
   then
     log -e "${DIR} does not exist."
     return;
   elif [ ! -d ${DIR} ]
   then
     log -e "${DIR} is not a directory."
     return;
   fi 

   local DO_FIND="find ${DIR} ${TYPE} -name '${1}'"
   log $DO_FIND
   eval $DO_FIND

   log -w "Are you sure you want to delete all the files listed above?"
   if ask -n "Push the button? "
       then
       
       # Find all files by pattern
       for file in `eval $DO_FIND`
	 do
	 log "+ Removing ..... $file"
	 rm -rf $file
       done
   fi

done
IFS=$ORIGINAL_IFS

}

function repl(){

# MUST RESET OPTIND
OPTIND=1
local FIRST_ARG
local FIRST_ARG_IDX
local LAST_OPTION
local LAST_OPTION_IDX

declare -a REPL_ARGS
local BE_QUIET=off
local DELIM="@"
local DIR=`pwd`
local IS_SUDO="off"

while getopts "qsd:D:" flag
do
    case "$flag" in
      q)  BE_QUIET=on;;
      d)  DIR="${OPTARG}";;
      s)  IS_SUDO="on";;
      D)  DELIM="${OPTARG}";;
      \?) log
          log "Usage:"
          log "replace \"old text\" \"new text\" '[glob pattern]' "
          log
          log "For Example:"
          log "replace \"sites/clientX\" \"/new/clientX\" '*.html'"
          log
    
          return 1;;
    esac
done


#Check if first parameter is a directory
if [ ! -d ${DIR} ]
then 
    log -e "${DIR} is not a directory"
    return 1
fi

let LAST_OPTION=${OPTIND}
let LAST_OPTION--

let LAST_OPTION_IDX=LAST_OPTION
let LAST_OPTION_IDX--

# ---------------------------------------------------
# FIND REGEX
# ---------------------------------------------------
local count=0
local ARG_COUNT=0
local rarg
if [ $# -gt ${LAST_OPTION_IDX} ]
then
   for rarg in "$@"
   do
    #log you typed ${file} ${count}.
    if [ $count -gt ${LAST_OPTION_IDX} ]
    then
        REPL_ARGS[ARG_COUNT]="${rarg}"

	let ARG_COUNT++
    fi

    let count++

   done

fi 

local DO_REPLACE="on"
if [ ${BE_QUIET} = "off" ]
then
log -w "You must ensure all delimiter charaters in your input strings are escaped." 

if ask -y "The delimiter character is ${DELIM}. Do you wish to continue? "
then
DO_REPLACE="on"
else
DO_REPLACE="off"
fi
fi


if [ ${DO_REPLACE} = "on" ]
then

    local FIND=`which find`
    if [ ${IS_SUDO} = "on" ]
    then
	FIND="sudo ${FIND}"
    fi
    local DO_FIND="${FIND} ${DIR}/ -name '${REPL_ARGS[2]}'"
    log -d "Find command is ${DO_FIND}"
    local REP="${DO_FIND} | xargs perl -pi -e 's${DELIM}${REPL_ARGS[0]}${DELIM}${REPL_ARGS[1]}${DELIM}g'"
    #log "Just testing:" ${REP}
    eval ${REP}
    return;
fi

}

#log "Do you really want to remove 1230 files (yes/no)?"
#The script "ask()" allows for easy prompting, e.g.
#if ask -y "really remove $n files"
#then
#  rm -f "$allfiles"
#fi
function ask() {
          #
          # ask a question with a yes/no answer;
          # Usage: ask [-y|-n] "question"
          # Set default: -y = yes; -n = no; otherwise no default;
          # Returns: 0 (true) = yes; 1 (false) = no;
          # Note: changing the default does not effect the return value;
          #
          ASK_DFLT=
          # process options/args
          for ASK_OPT do
                case "$ASK_OPT" in
                  -[yY]*) ASK_DFLT='y' ;;
                  -[nN]*) ASK_DFLT='n' ;;
                  --) shift; break ;;
                  -*) ;;
                  *) break
                  esac
                shift
            done
          ASK_PROMPT="$*"

          # get the response
          while : ; do
                log -n "$ASK_PROMPT (y/n)?${ASK_DFLT:+ [$ASK_DFLT]} " >&2
                read ASK_ANSWER ASK_JUNK

                : ${ASK_ANSWER:=$ASK_DFLT}

                case "$ASK_ANSWER" in
                  [yY]*)
                        return 0
                        ;;
                  [nN]*)
                        return 1
                        ;;
                  *)
                        log " " >&2
                  esac
            done

          return
        }


function dos2unix(){

    if [ $# = 1 ]
	then
	if [ -d ${1} ]
	    then
	    log "ok directory ${1} exists, replacing ${1} for ${2}"   
	else
	    log "${1} is not a directory"
            log "Usage: dos2unix [myfile|mydir]"
	    return 1
	fi
    else
	log "Usage: dos2unix [myfile|mydir]"
	return 1
    fi

    local DIR=`pwd`
    local file

    for file in `ls -r ${1}`
    do
      log "${1}/${file}"
      if [ -d ${1}/${file} ]
	  then
	   dos2unix ${DIR}${1}/${file}
      else

	  local E_WRONGARGS=65

	  local ORIG_FILE=${DIR}/${1}/${file}
          local NEWFILENAME=${ORIG_FILE}.unx

          local CR='\015'  # Carriage return.
          # Lines in a DOS text file end in a CR-LF.

          tr -d $CR < $1 > $NEWFILENAME
          # Delete CR and write to new file.

          #log "Original DOS text file is \"$ORIG_FILE\"."
          #log "Converted UNIX text file is \"$NEWFILENAME\"."
	  
          if ask -y "replace original \"$ORIG_FILE\" with \"$NEWFILENAME\"?"
          then
	    rm ${ORIG_FILE}
	    mv ${NEWFILENAME} ${ORIG_FILE}
          fi

      fi
    done

}




# usage: array_remove mapname key
# removes from the map given by mapname the entry for key, if any
function array_remove() {
local table=${!1}
local key=$(array_encode "$2")
local head=${table%||$key|=*}
if [ "$head" = "$table" ]; then return; fi
local tail="${table#*||$key|=*||}"
eval "$1"='"${head}||${tail}"'
}

# usage: array_get mapname key [default]
function array_get() {
# usage: array_get mapname
local table=${!1}
local key=$(array_encode "$2")
local dflt=$3

local tail="${table#*||$key|=}"
if [ "$table" = "$tail" ]; then echo "$dflt"; return; fi
local value=$(array_decode "${tail%%||*}")
echo "$value"
}

# usage: array_put mapname key value
# enters the key/value pair into the map with the name mapname
function array_put() {
if [ -z "${!1}" ]; then eval "$1"='"||"'; fi
local key=$(array_encode "$2")
local value=$(array_encode "$3")
array_remove "$1" "$2"
local table="${!1}"
eval "$1"='"||$key|=${value}$table"'
}

# usage: mapname aryname
# Enters all keys found in the map with name mapnam into the array
# given by aryname.
# Example: array_keys map keys; for x in "${keys[@]}"; dodone;
function array_keys() {
local table=${!1}
local aname=$2
local l
while [ "$table" != "||" ]; do
local key=$(array_decode "${table%%|=*}")
eval l=\${\#${aname}[@]}
eval ${aname}[$l]='${key#||}'
table="||${table#||*||}"
done
}
function array_encode() {
local p=${1//|/|.}
echo "$p"
}
function array_decode() {
local p=${1//|./|}
echo "$p"
}


# simple example
#array_put test "WARN" 5
#array_get test "WARN"
#echo $test


# Unsorted examples and test cases.
#array_put ary bsq "\\'"
#array_put ary quote \'
#array_put ary dquote '"'
#array_put ary '"' aaaa
#array_put ary \' bbb
#array_put ary "a\
#a" bbb
#array_put ary "X X" "y y"
#array_put ary " ' ' ' " ' " " " '
#array_put ary ' " " " ' " ' ' ' "

#echo $ary

reset_color

